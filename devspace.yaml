version: v2beta1
name: vantage6git

# TODO using tags isnt safe with the devspace build stuff
vars:
  SERVER_IMAGE: harbor2.vantage6.ai/infrastructure/server
  NODE_IMAGE: harbor2.vantage6.ai/infrastructure/node
  STORE_IMAGE: harbor2.vantage6.ai/infrastructure/algorithm-store
  UI_IMAGE: harbor2.vantage6.ai/infrastructure/ui
  NODE_TEST_DATABASE_FILE:
    question: "Where is your test data for the node located?"
    default: ${PWD}/dev/olympic_athletes_2016.csv
  KUBE_CONFIG:
    question: "Where is your kube config from k8s located?"
    default: ${DEVSPACE_USER_HOME}/.kube/config
  TASK_DIRECTORY:
    question: "Where is your task directory located on the host machine?"
    default: ${PWD}/.tasks
  #set to 0.0.0.0 to make the dev environment (ui, api) accessible from outside
  # PORTS_BIND_ADDRESS: "127.0.0.1"
  NUMBER_OF_NODES:
    question: "How many nodes do you want to create for your development environment?"
    default: 2

pipelines:

  # Main entrypoint for development (`devspace dev`). This starts all server components
  # and the nodes. Make sure that you have run `devspace run-pipeline init` before.
  dev:
    run: |-
      run_dependencies --all
      run_pipelines \
        server \
        node \
        --sequential

  # Initialize a development vantage6 network. This will create the necessary
  # entities at the server (e.g. organizations, nodes, etc.), generate the node
  # configuration files (stores these in the `dev/.data` directory) and finally
  # connects the local store to the server.
  # TODO register the diagnostics image in the algorithm store
  init:
    run: |-
      run_dependencies --all
      ensure_pull_secrets --all
      create_deployments \
        vantage6-server
      create_deployments \
        vantage6-store
      start_dev \
        vantage6-server-init \
        vantage6-store-init
      # TODO replace this with a retry mechanism
      echo "Waiting for server to start... (30 seconds)"
      sleep 30
      python dev/delete-basic-fixtures.py
      python dev/load-basic-fixtures.py --number-of-nodes $NUMBER_OF_NODES
      python dev/connect-store.py
      stop_dev --all

  server:
    run: |-
      run_dependencies --all
      ensure_pull_secrets --all
      create_deployments \
        vantage6-server \
        vantage6-store
      start_dev \
        vantage6-server \
        vantage6-ui \
        vantage6-store

  node:
    run: |-
      create_deployments \
        vantage6-node
      start_dev \
        vantage6-node

# This is a list of `images` that DevSpace can build for this project. These can be
# build with `devspace build` or when running `devspace dev -b`.
images:
  server:
    image: ${SERVER_IMAGE}
    dockerfile: docker/node-and-server.Dockerfile
    context: .

  node:
    image: ${NODE_IMAGE}
    dockerfile: docker/node-and-server.Dockerfile
    context: .

  store:
    image: ${STORE_IMAGE}
    dockerfile: docker/algorithm-store.Dockerfile
    context: .

  ui:
    image: "${UI_IMAGE}"
    dockerfile: docker/ui_dev.Dockerfile
    context: .

# This is a list of `deployments` that DevSpace can create for this project
deployments:

  # The server deployment contains the server, database, rabbit mq and the UI. The
  # store is deployed separately as it can have an many-to-many relationship with the
  # server (This is also why they are in separate Helm charts).
  vantage6-server:
    helm:
      chart:
        name: ./charts/server
      values:
        server:
          image: ${SERVER_IMAGE}
          logging:
            level: DEBUG
          jwt:
            secret: development-constant-secret!

        database:
          volumePath: /mnt/data_server

  # The store deployment contains the store and the database.
  vantage6-store:
    helm:
      chart:
        name: ./charts/store
      values:
        store:
          image: ${STORE_IMAGE}
          logging:
            level: DEBUG
          vantage6Server:
            uri: http://host.docker.internal:7601/server
          policies:
            allowLocalhost: 'True'

        # This is the location of the database on the host system. Depending on the
        # system that you use in combination with Docker Desktop, you should put a
        # different path here.
        #
        # WSL
        #   volumePath: /run/desktop/mnt/host/wsl/[SOME_PATH]
        # MacOS
        #   volumePath: ???
        # Linux
        #  users can probably use the same path as in the example below. Or any other
        #  path that is accessible by the Docker daemon.
        database:
          volumePath: /mnt/data_store

  # The node deployment should not be 'deployed' only, it should only be deployed in
  # combination with the `dev` container (The node container that is started by the
  # `dev` section of this file). This is because the node deployment requires the
  # configuration files that are generated by the `dev` container. These are then
  # mounted into the node container. The node starts then in development mode using
  # the `dev_start.py` script. This allows us to run multiple nodes in a single
  # container. The good part about this is that all nodes receive hot-reloaded code :)
  vantage6-node:
    helm:
      chart:
        name: ./charts/node
      values:
        node:
          taskDirHost: ${TASK_DIRECTORY}
          image: ${NODE_IMAGE}
          logging:
            level: DEBUG
          databases:
            fileBased:
            - name: default
              uri: ${NODE_TEST_DATABASE_FILE}
              type: csv
            # serviceBased:
            # - name: postgres
            #   uri: postgres://vantage6:vantage6@vantage6-vantage6-postgres:5432/vantage6
            #   type: other
          kubeConfig: ${KUBE_CONFIG}


# This is a list of `dev` containers that are based on the containers created by your deployments
dev:

  # we use this to populate the database with some basic data. We need a port to talk
  # to as the ingress is not deployed yet.
  vantage6-server-init:
    imageSelector: ${SERVER_IMAGE}
    ports:
      - port: 7601:7601
        # bindAddress: ${PORTS_BIND_ADDRESS}

  # We use this to enable the server and the store to be coupled. We need a port to talk
  # to as the ingress is not deployed yet.
  vantage6-store-init:
    imageSelector: ${STORE_IMAGE}
    ports:
      - port: 7602:7602
        # bindAddress: ${PORTS_BIND_ADDRESS}

  vantage6-store:
    imageSelector: ${STORE_IMAGE}
    ports:
      - port: 7602:7602
        # bindAddress: ${PORTS_BIND_ADDRESS}

    sync:
    - path: ./vantage6/:/vantage6/vantage6/
      disableDownload: true
    - path: ./vantage6-common/:/vantage6/vantage6-common/
      disableDownload: true
    - path: ./vantage6-backend-common/:/vantage6/vantage6-backend-common/
      disableDownload: true
    - path: ./vantage6-algorithm-store/:/vantage6/vantage6-algorithm-store/
      disableDownload: true
      startContainer: true
    command: ["/bin/sh", "/vantage6/vantage6-algorithm-store/dev_store.sh"]

  # This puts the server container in development mode. It syncs the local files with
  # the container and starts the server in development mode. Code changes will be
  # hot-reloaded and a port forward is created to access the server.
  vantage6-server:
    imageSelector: ${SERVER_IMAGE}
    sync:
    - path: ./vantage6/:/vantage6/vantage6/
      disableDownload: true
    - path: ./vantage6-common/:/vantage6/vantage6-common/
      disableDownload: true
    - path: ./vantage6-backend-common/:/vantage6/vantage6-backend-common/
      disableDownload: true
    - path: ./vantage6-server/:/vantage6/vantage6-server/
      disableDownload: true
      startContainer: true
    command: ["/bin/sh", "/vantage6/vantage6-server/dev_server.sh"]
    proxyCommands:
      - command: devspace
      - command: kubectl
    ports:
      - port: 7601:7601
        # bindAddress: ${PORTS_BIND_ADDRESS}
    logs:
      enabled: true

  # This puts the store container in development mode.
  vantage6-ui:
    imageSelector: ${UI_IMAGE}
    sync:
    - path: ./vantage6-ui/:/app/
      disableDownload: true
    ports:
      - port: 7600:80
        # bindAddress: ${PORTS_BIND_ADDRESS}

  # Where as we could hot-reload the server code using wsgi, we cannot do this with the
  # node code. We leverage the `restartHelper` and `onUpload.restartContainer` to
  # restart the node container (with multiple nodes) when the code changes.
  vantage6-node:
    imageSelector: ${NODE_IMAGE}
    sync:
    - path: ./vantage6/:/vantage6/vantage6/
      disableDownload: true
      onUpload:
        restartContainer: true
    - path: ./vantage6-common/:/vantage6/vantage6-common/
      disableDownload: true
      onUpload:
        restartContainer: true
    - path: ./vantage6-node/:/vantage6/vantage6-node/
      disableDownload: true
      onUpload:
        restartContainer: true
    # It is possible to manually add nodes. You need to put the configuration files in
    # the `dev/.data` directory. The `dev_start.py` script will then start the nodes.
    - path: ./dev/.data/:/mnt/config/
      disableDownload: true
      startContainer: true
      onUpload:
        restartContainer: true

    restartHelper:
      inject: true

    command: ["python", "/vantage6/vantage6-node/vantage6/dev_start.py", "/mnt/config/"]



# Use the `commands` section to define repeatable dev workflows for this project
commands:
  # This command will spin up a server and store temporary to fill it with some
  # basic data.
  populate-server:
    description: "Populate the server with fixtures for a given number of nodes"
    command: devspace run-pipeline init

  # This will put all components in development mode. This is the main entrypoint
  # for development.
  start-dev:
    description: "Start the development environment"
    command: devspace dev

  # This will stop all components from the development mode. Note that the deployments
  # are not deleted.
  stop-dev:
    description: "Stop the development environment"
    command: devspace reset pods

  # This will delete all deployments and services. This is useful when you want to
  # start from scratch.
  purge:
    description: "Purge the development environment"
    command: devspace purge

  # This will build all images for this project. This is probably the first command
  # you want to run. In case you do not run it, it will pull the latest images from
  # our harbor registry (which potentially has outdated dependencies).
  rebuild:
    description: "Rebuild all images for this project"
    command: devspace build


# Define dependencies to other projects with a devspace.yaml
# dependencies:
#   api:
#     git: https://...  # Git-based dependencies
#     tag: v1.0.0
#   ui:
#     path: ./ui        # Path-based dependencies (for monorepos)
